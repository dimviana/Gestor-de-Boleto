import sys
import json
import re
import fitz  # PyMuPDF
import datetime

def clean_ocr_mistakes(value):
    """Corrects common OCR character misinterpretations."""
    if not value:
        return ''
    return value.replace('O', '0').replace('o', '0').replace('º', '0') \
                .replace('I', '1').replace('l', '1') \
                .replace('S', '5').replace('s', '5').replace('§', '5') \
                .replace('B', '8') \
                .replace('Z', '2').replace('z', '2') \
                .replace('G', '6')

def extract_barcode(text):
    """Extracts the 47 or 48-digit barcode from text, trying multiple patterns."""
    # Pattern for barcode with formatting
    pattern1 = r'\b(\d{5}\.?\d{5}\s+\d{5}\.?\d{6}\s+\d{5}\.?\d{6}\s+\d\s+\d{14})\b'
    # Pattern for a solid block of 47 or 48 digits
    pattern2 = r'\b(\d{47,48})\b'
    # Pattern for barcode split across multiple lines
    pattern3 = r'(\d{5}\.?\d{5})[\s\n]+(\d{5}\.?\d{6})[\s\n]+(\d{5}\.?\d{6})[\s\n]+(\d)[\s\n]+(\d{14})'
    
    # Clean the text before matching
    cleaned_text = clean_ocr_mistakes(text)

    match = re.search(pattern1, cleaned_text)
    if match:
        return re.sub(r'[^\d]', '', match.group(1))

    match = re.search(pattern2, cleaned_text)
    if match:
        return match.group(1)

    match = re.search(pattern3, cleaned_text)
    if match:
        return ''.join(re.sub(r'[^\d]', '', g) for g in match.groups())

    return None

def parse_currency(value):
    """Parses a string into a float, handling Brazilian currency format."""
    if not value:
        return None
    
    value_str = str(value).strip().upper().replace('R$', '').replace('RS', '').strip()
    
    # Remove thousand separators and replace comma decimal separator
    if '.' in value_str and ',' in value_str:
        if value_str.rfind('.') < value_str.rfind(','): # Format: 1.234,56
             value_str = value_str.replace('.', '').replace(',', '.')
        else: # Format: 1,234.56
            value_str = value_str.replace(',', '')
    elif ',' in value_str: # Only comma, assume it's the decimal separator
        value_str = value_str.replace('.', '').replace(',', '.')

    try:
        num = float(re.sub(r'[^\d.]', '', value_str))
        return round(num, 2)
    except (ValueError, TypeError):
        return None

def parse_date(value):
    """Parses a DD/MM/YYYY string into YYYY-MM-DD format."""
    if not value:
        return None
    match = re.search(r'(\d{2})[/\sIl](\d{2})[/\sIl](\d{4})', str(value))
    if match:
        day, month, year = match.groups()
        try:
            # Validate date components before creating a date object
            if 1 <= int(month) <= 12 and 1 <= int(day) <= 31:
                return f"{year}-{month.zfill(2)}-{day.zfill(2)}"
        except ValueError:
            return None
    return None

def extract_entity(text, pattern):
    """Extracts a multi-line entity based on a starting keyword."""
    match = re.search(pattern, text, re.I | re.DOTALL)
    if not match:
        return None
    
    # Clean up the extracted text block
    result = match.group(1).strip()
    result = re.sub(r'\s*\n\s*', ' / ', result) # Replace newlines with slashes
    result = re.sub(r'\s{2,}', ' ', result) # Condense multiple spaces
    result = re.sub(r'[-_]+', ' ', result).strip()
    return result if result else None


def main():
    try:
        # Read PDF from standard input
        pdf_data = sys.stdin.buffer.read()
        doc = fitz.open(stream=pdf_data, filetype="pdf")
        
        full_text = ""
        for page in doc:
            full_text += page.get_text("text", sort=True) + "\n"
        
        # Define regex patterns for extraction
        patterns = {
            'amountValorDocumento': r'(?:Valor\sdo\sDocumento)[\s:R$]*([\d,.-]+)',
            'amountValorCobrado': r'(?:Valor\sCobrado)[\s:R$]*([\d,.-]+)',
            'dueDate': r'(?:Vencimento)[\s:]*(\d{2}/\d{2}/\d{4})',
            'documentDate': r'(?:Data\s(?:do\s)?Documento)[\s:]*(\d{2}/\d{2}/\d{4})',
            'recipient': r'(?:Benefici[áa]rio|Cedente)[\s.:\n]*?([\s\S]*?)(?=\b(?:Data (?:do )?Documento|Vencimento|Nosso Número|Ag.ncia)\b)',
            'drawee': r'(?:Pagador|Sacado)[\s.:\n]*?([\s\S]*?)(?=\b(?:Instruç|Descriç|Autenticaç)\b|Mora/Multa)',
            'guideNumberDoc': r'(?:N[ºo\.]?\s?(?:do\s)?Documento)[\s.:\n]*?(\S+)',
            'guideNumberNosso': r'(?:Nosso\sN[úu]mero)[\s.:\n]*?(\S+)',
            'pixQrCodeText': r'(000201\S{100,})',
            'discount': r'(?:Desconto|Abatimento)[\s:R$]*([\d,.-]+)',
            'interestAndFines': r'(?:Juros|Multa|Acr[ée]scimos)[\s:R$]*([\d,.-]+)',
        }
        
        data = {}

        # Simple field extractions
        data['dueDate'] = parse_date(re.search(patterns['dueDate'], full_text, re.I).group(1) if re.search(patterns['dueDate'], full_text, re.I) else None)
        data['documentDate'] = parse_date(re.search(patterns['documentDate'], full_text, re.I).group(1) if re.search(patterns['documentDate'], full_text, re.I) else None)
        
        # Currency fields
        data['documentAmount'] = parse_currency(re.search(patterns['amountValorDocumento'], full_text, re.I).group(1) if re.search(patterns['amountValorDocumento'], full_text, re.I) else None)
        data['discount'] = parse_currency(re.search(patterns['discount'], full_text, re.I).group(1) if re.search(patterns['discount'], full_text, re.I) else None)
        data['interestAndFines'] = parse_currency(re.search(patterns['interestAndFines'], full_text, re.I).group(1) if re.search(patterns['interestAndFines'], full_text, re.I) else None)
        
        amount_cobrado = parse_currency(re.search(patterns['amountValorCobrado'], full_text, re.I).group(1) if re.search(patterns['amountValorCobrado'], full_text, re.I) else None)
        data['amount'] = amount_cobrado if (amount_cobrado is not None and amount_cobrado > 0) else data.get('documentAmount')

        # Complex fields with fallbacks
        guide_number_match = re.search(patterns['guideNumberDoc'], full_text, re.I)
        if not guide_number_match:
            guide_number_match = re.search(patterns['guideNumberNosso'], full_text, re.I)
        data['guideNumber'] = guide_number_match.group(1).strip() if guide_number_match else None

        data['recipient'] = extract_entity(full_text, patterns['recipient'])
        data['drawee'] = extract_entity(full_text, patterns['drawee'])
        
        # Special extractions
        data['barcode'] = extract_barcode(full_text)
        pix_match = re.search(patterns['pixQrCodeText'], full_text)
        data['pixQrCodeText'] = pix_match.group(1) if pix_match else None

        # Return JSON
        print(json.dumps(data))

    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()