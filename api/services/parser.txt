# -*- coding: utf-8 -*-
import sys
import fitz  # PyMuPDF
import json
import re
import os

# --- Helper Functions for Data Cleaning and Parsing ---

def clean_text(value):
    """Removes leading/trailing whitespace, collapses multiple spaces, and normalizes line breaks."""
    if not value:
        return None
    return re.sub(r'\s+', ' ', value).strip()

def parse_currency(value_str):
    if not value_str:
        return None
    try:
        value_str = value_str.replace('O', '0').replace('o', '0').replace('l', '1').replace('I', '1').replace('S', '5').replace('B', '8')
        cleaned_str = re.sub(r'(?i)R\$\s*', '', value_str).strip()
        if ',' in cleaned_str and '.' in cleaned_str:
            cleaned_str = cleaned_str.replace('.', '').replace(',', '.')
        elif ',' in cleaned_str:
            cleaned_str = cleaned_str.replace(',', '.')
        numeric_str = re.sub(r'[^\d.]', '', cleaned_str)
        if not numeric_str:
            return None
        num = float(numeric_str)
        return round(num, 2)
    except (ValueError, TypeError):
        return None

def parse_date(value_str):
    if not value_str:
        return None
    try:
        cleaned_str = value_str.replace(' ', '/').replace('.', '/').replace('l', '1').replace('I', '1').replace('o','0').replace('O','0')
        match = re.search(r'(\d{1,2})[/\s](\d{1,2})[/\s](\d{4})', cleaned_str)
        if match:
            day, month, year = map(int, match.groups())
            if 0 < day <= 31 and 0 < month <= 12 and year > 1900:
                return f"{year:04d}-{month:02d}-{day:02d}"
        return None
    except (ValueError, TypeError):
        return None

def extract_barcode(text):
    block_pattern = r'\b(\d{5}[.\s]?\d{5})\s*(\d{5}[.\s]?\d{6})\s*(\d{5}[.\s]?\d{6})\s*(\d)\s*(\d{14})\b'
    match = re.search(block_pattern, text)
    if match:
        return re.sub(r'[^\d]', '', match.group(0))
    cleaned_text = text.replace('O', '0').replace('o', '0').replace('l', '1').replace('I', '1').replace('S', '5').replace('B', '8')
    for line in cleaned_text.split('\n'):
        numeric_line = re.sub(r'[^\d]', '', line)
        if 47 <= len(numeric_line) <= 48:
            return numeric_line
    contiguous_match = re.search(r'\b\d{47,48}\b', cleaned_text)
    if contiguous_match:
        return contiguous_match.group(0)
    return None

def find_pix_code(text):
    match = re.search(r'(000201[\s\S]*?6304[A-F0-9]{4})', text, re.IGNORECASE)
    if match:
        pix_code_with_whitespace = match.group(1)
        cleaned_code = re.sub(r'\s+', '', pix_code_with_whitespace)
        return cleaned_code
    return None

def extract_detailed_costs(text):
    """Extracts detailed cost items, robust to different layouts."""
    costs = {}
    labels = ['Emolumento', 'TSNR', 'FERC', 'FERM', 'FUNSEG', 'ISS', 'Tarifa Banco']
    for i, label in enumerate(labels):
        next_delimiters = labels[i+1:] + ['Totais', 'Valor Cobrado', '(=) Valor Cobrado']
        next_pattern = '|'.join(map(re.escape, next_delimiters))
        pattern = re.compile(rf'\b({re.escape(label)})\b([\s\S]*?)(?=\b(?:{next_pattern})\b|$)', re.IGNORECASE)
        match = pattern.search(text)
        if match:
            content_after_label = match.group(2)
            currency_match = re.search(r'R\$\s*([\d,.]+)', content_after_label)
            if currency_match:
                value = parse_currency(currency_match.group(1))
                if value is not None:
                    key = label
                    if 'Tarifa' in key: key = 'Tarifa Banco'
                    costs[key] = value
    return costs if costs else None

# --- Main Extraction Logic ---

def extract_boleto_info(pdf_path):
    text_content = ""
    try:
        with fitz.open(pdf_path) as doc:
            for page in doc:
                text_content += page.get_text("text", sort=True) + "\n"
    except Exception as e:
        print(json.dumps({"error": f"PyMuPDF error reading PDF: {str(e)}"}, ensure_ascii=False), file=sys.stderr)
        return {"error": f"PyMuPDF error reading PDF: {str(e)}"}

    PATTERNS = {
        "recipient": r'(?i)(?:Beneficiário|Cedente)[\s:.]*\n?([\s\S]*?)(?=\n\s*(?:CNPJ:|Agência|Nosso Número|Sacado|Pagador|Data (?:do )?Documento|Vencimento|AGÊNCIA \/ CÓDIGO DO BENEFICIÁRIO)|$)',
        "drawee": r'(?i)(?:Pagador|Sacado)[\s:.]*\n?([\s\S]*?)(?=\n\s*\b(?:Sacador / Avalista|Instruções|Descrição|Autenticação Mecânica|FICHA DE COMPENSAÇÃO|Nosso Número)\b|$)',
        "dueDate": r'(?i)Vencimento\s*\n?\s*(\d{2}[/.]\d{2}[/.]\d{4})',
        "documentDate": r'(?i)Data (?:do )?Documento\s*\n?\s*(\d{2}[/.]\d{2}[/.]\d{4})',
        "amount_cobrado": r'(?i)\(=\)\s*Valor Cobrado\s*\n?\s*(R\$\s*[\d,.]+)',
        "amount_documento": r'(?i)(?:\(=\))?\s*Valor do Documento\s*\n?\s*(R\$\s*[\d,.]+)',
        "discount": r'(?i)\(-\)\s*(?:Desconto|Abatimento)\s*\n?\s*(R\$\s*[\d,.]+)',
        "interestAndFines": r'(?i)\(\+\)\s*(?:Juros|Multa|Mora|Acréscimos)\s*\n?\s*(R\$\s*[\d,.]+)',
    }

    def find_first_match(pattern, text):
        match = re.search(pattern, text)
        return clean_text(match.group(1)) if match else None

    def find_last_match(pattern_key, text):
        matches = re.findall(PATTERNS[pattern_key], text)
        return clean_text(matches[-1]) if matches else None

    # --- Guide Number Extraction ---
    final_guide_number = None
    
    # Priority 1: "Nosso Número"
    nosso_numero_pattern = r'(?i)Nosso\sN[úu]mero\s*\n?\s*([\d.-/]+)'
    nosso_numero_match = re.search(nosso_numero_pattern, text_content)
    if nosso_numero_match:
        cleaned = re.sub(r'[^\d]', '', nosso_numero_match.group(1))
        if cleaned:
            final_guide_number = cleaned

    # Priority 2: Fallback to "Nº Documento" if "Nosso Número" is not found
    if not final_guide_number:
        same_line_pattern = r'N[º°o\.]?\s*Documento(?:[/]?Guia)?\s*(\d{8,15}\b)'
        same_line_match = re.search(same_line_pattern, text_content, re.IGNORECASE)
        if same_line_match:
            final_guide_number = same_line_match.group(1)
            
    if not final_guide_number:
        next_line_pattern = r'N[º°o\.]?\s*Documento(?:[/]?Guia)?\s*\n\s*(\d{8,15}\b)'
        next_line_match = re.search(next_line_pattern, text_content, re.IGNORECASE)
        if next_line_match:
            final_guide_number = re.sub(r'[^\d]', '', next_line_match.group(1))

    raw = {
        "recipient": find_first_match(PATTERNS["recipient"], text_content),
        "drawee": find_first_match(PATTERNS["drawee"], text_content),
        "dueDate": find_last_match("dueDate", text_content),
        "documentDate": find_last_match("documentDate", text_content),
        "amount_cobrado": find_last_match("amount_cobrado", text_content),
        "amount_documento": find_last_match("amount_documento", text_content),
        "discount": find_last_match("discount", text_content),
        "interestAndFines": find_last_match("interestAndFines", text_content),
        "barcode": extract_barcode(text_content),
        "pixQrCodeText": find_pix_code(text_content),
    }

    amount_cobrado = parse_currency(raw["amount_cobrado"])
    amount_documento = parse_currency(raw["amount_documento"])
    final_amount = amount_cobrado if amount_cobrado is not None and amount_cobrado > 0 else amount_documento
    detailed_costs = extract_detailed_costs(text_content)

    result = {
        "recipient": raw["recipient"],
        "drawee": raw["drawee"],
        "documentDate": parse_date(raw["documentDate"]),
        "dueDate": parse_date(raw["dueDate"]),
        "documentAmount": amount_documento,
        "amount": final_amount,
        "discount": parse_currency(raw["discount"]),
        "interestAndFines": parse_currency(raw["interestAndFines"]),
        "barcode": raw["barcode"],
        "guideNumber": final_guide_number,
        "pixQrCodeText": raw["pixQrCodeText"],
        "detailedCosts": detailed_costs,
    }

    return result

if __name__ == "__main__":
    if len(sys.argv) > 1:
        pdf_file_path = sys.argv[1]
        if not os.path.exists(pdf_file_path):
            print(json.dumps({"error": "PDF file not found at path: " + pdf_file_path}, ensure_ascii=False), file=sys.stderr)
            print(json.dumps({"error": "PDF file not found at path: " + pdf_file_path}, ensure_ascii=False))
            sys.exit(1)
            
        extraction_result = extract_boleto_info(pdf_file_path)
        print(json.dumps(extraction_result, ensure_ascii=False))
    else:
        print(json.dumps({"error": "No PDF file path provided."}, ensure_ascii=False), file=sys.stderr)
        print(json.dumps({"error": "No PDF file path provided."}, ensure_ascii=False))
        sys.exit(1)