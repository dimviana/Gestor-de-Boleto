# -*- coding: utf-8 -*-
import sys
import fitz  # PyMuPDF
import json
import re

def clean_ocr_mistakes(value):
    """Corrects common OCR character misinterpretations for numbers."""
    if not value: return ''
    return value.replace('O', '0').replace('º', '0') \
                .replace('I', '1').replace('l', '1') \
                .replace('S', '5').replace('B', '8') \
                .replace('Z', '2').replace('G', '6') \
                .replace('§', '5')

def parse_currency(value_str):
    """
    Parses a string representing a Brazilian currency value into a float.
    Handles formats like '1.234,56' and '1234,56' and strips 'R$'.
    """
    if not value_str: return None
    try:
        value_str = clean_ocr_mistakes(value_str.strip())
        # Remove currency symbols and surrounding whitespace
        value_str = re.sub(r'R\$\s*', '', value_str, flags=re.IGNORECASE).strip()

        # If there's no digit, it's not a valid amount
        if not re.search(r'\d', value_str):
            return None

        # Standardize format to use '.' as decimal separator
        if ',' in value_str:
            value_str = value_str.replace('.', '').replace(',', '.')
        
        # Remove any non-numeric characters except the decimal point
        num_str = re.sub(r'[^\d.]', '', value_str)
        if not num_str: return None

        num = float(num_str)
        
        # Sanity check for extremely large values which are likely OCR errors
        if num > 99999999.0:
            return None
            
        return round(num, 2)
    except (ValueError, TypeError):
        return None

def parse_date(value_str):
    """Parses a date string in DD/MM/YYYY format, allowing for OCR errors."""
    if not value_str: return None
    try:
        cleaned_str = clean_ocr_mistakes(value_str)
        match = re.search(r'(\d{2})[/\s.Il]?(\d{2})[/\s.Il]?(\d{4})', cleaned_str)
        if match:
            day, month, year = match.groups()
            day_int, month_int, year_int = int(day), int(month), int(year)
            # Basic date validation
            if 0 < day_int <= 31 and 0 < month_int <= 12 and year_int > 1900:
                return f"{year}-{str(month_int).zfill(2)}-{str(day_int).zfill(2)}"
        return None
    except (ValueError, TypeError):
        return None

def extract_barcode(text):
    """Finds and cleans the 47 or 48-digit barcode from the text."""
    patterns = [
        r'\b(?:\d{5}\.\d{5}\s+\d{5}\.\d{6}\s+\d{5}\.\d{6}\s+\d\s+\d{14})\b',
        r'\b(?:\d{11,12}\s*[-]?\s*\d\s*\d{11,12}\s*[-]?\s*\d\s*\d{11,12}\s*[-]?\s*\d\s*\d{11,12}\s*[-]?\s*\d)\b',
        r'\b\d{47,48}\b'
    ]
    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            return re.sub(r'[^0-9]', '', match.group(0))
    return None

def find_match(text, pattern, find_last=False):
    """Helper to find the first or last match of a pattern."""
    try:
        matches = re.findall(pattern, text, re.IGNORECASE | re.DOTALL)
        if matches:
            # Clean up the matched string
            result = matches[-1] if find_last else matches[0]
            result = re.sub(r'\s*\n\s*', ' / ', str(result)).strip()
            return re.sub(r'\s{2,}', ' ', result)
    except (re.error, IndexError):
        pass
    return None

def extract_boleto_info(pdf_path):
    text_content = ""
    try:
        with fitz.open(pdf_path) as doc:
            for page in doc:
                text_content += page.get_text("text") + "\n"
    except Exception as e:
        print(json.dumps({"error": f"Failed to open or read PDF with PyMuPDF: {str(e)}"}, ensure_ascii=False))
        sys.exit(1)

    # Prioritize 'Valor Cobrado', fall back to 'Valor do Documento'
    amount_str = find_match(text_content, r'(?:\(=\))?\s*Valor Cobrado[^\d,]*?((?:R\$\s*)?[\d.,]+)', find_last=True)
    doc_amount_str = find_match(text_content, r'(?:\(=\))?\s*Valor (?:do )?Documento[^\d,]*?((?:R\$\s*)?[\d.,]+)', find_last=True)
    
    amount = parse_currency(amount_str)
    doc_amount = parse_currency(doc_amount_str)
    
    if amount is None or amount == 0:
        amount = doc_amount

    # Prioritize 'Nº Documento', fall back to 'Nosso Número'
    guide_number = find_match(text_content, r'N[ºo\.]?\s?(?:do\s)?Documento(?:[\/]?Guia)?[\s.:\n]*?(\S+)')
    if not guide_number:
        guide_number = find_match(text_content, r'Nosso\sN[úu]mero[\s.:\n]*?(\S+)')

    result = {
        "recipient": find_match(text_content, r'(?:Beneficiário|Cedente)[\s.:\n]*([\s\S]*?)(?=\n\s*(?:Data (?:do )?Documento|Vencimento|Nosso Número|Agência|CNPJ)|AGÊNCIA / CÓDIGO DO BENEFICIÁRIO)'),
        "drawee": find_match(text_content, r'(?:Pagador|Sacado)[\s.:\n]*?([\s\S]*?)(?=\n\s*\b(?:Instruções|Descrição|Autenticação Mecânica|FICHA DE COMPENSAÇÃO)\b)'),
        "documentDate": parse_date(find_match(text_content, r'Data (?:do )?Documento[^\d]*?(\d{2}[/\s.Il]?\d{2}[/\s.Il]?\d{4})', find_last=True)),
        "dueDate": parse_date(find_match(text_content, r'Vencimento[^\d]*?(\d{2}[/\s.Il]?\d{2}[/\s.Il]?\d{4})', find_last=True)),
        "documentAmount": doc_amount,
        "amount": amount,
        "discount": parse_currency(find_match(text_content, r'(?:\(-\))?\s*(?:Desconto\s*/\s*Abatimento)[^\d,]*?((?:R\$\s*)?[\d.,]+)', find_last=True)),
        "interestAndFines": parse_currency(find_match(text_content, r'(?:\(\+\))?\s*(?:Juros\s*/\s*Multa|Outros Acréscimos)[^\d,]*?((?:R\$\s*)?[\d.,]+)', find_last=True)),
        "barcode": extract_barcode(text_content),
        "guideNumber": guide_number,
        "pixQrCodeText": find_match(text_content, r'(000201\S{100,})'),
    }
    
    print(json.dumps(result, ensure_ascii=False))

if __name__ == "__main__":
    if len(sys.argv) > 1:
        pdf_file_path = sys.argv[1]
        extract_boleto_info(pdf_file_path)
    else:
        print(json.dumps({"error": "No PDF file path provided."}, ensure_ascii=False))
        sys.exit(1)