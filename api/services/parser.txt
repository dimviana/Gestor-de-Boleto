# -*- coding: utf-8 -*-
import sys
import fitz  # PyMuPDF
import json
import re
import os

# --- Data Cleaning and Parsing Helpers ---

def clean_text(value):
    """Removes leading/trailing whitespace, collapses multiple spaces, and normalizes line breaks to a single space."""
    if not value:
        return None
    # Replace multiple newlines/spaces with a single space and strip
    return re.sub(r'\s+', ' ', value).strip()

def ocr_fix(text):
    """Corrects common OCR character mistakes in text."""
    if not text:
        return text
    return text.replace('O', '0').replace('o', '0').replace('l', '1').replace('I', '1').replace('S', '5').replace('B', '8')

def parse_currency(value_str):
    """Parses a string representing Brazilian currency into a float."""
    if not value_str:
        return None
    try:
        # Correct common OCR errors in numbers
        cleaned_str = ocr_fix(value_str)
        # Remove currency symbol and whitespace
        cleaned_str = re.sub(r'(?i)R\$\s*', '', cleaned_str).strip()
        # Standardize decimal separators
        if ',' in cleaned_str and '.' in cleaned_str:
            cleaned_str = cleaned_str.replace('.', '').replace(',', '.')
        else:
            cleaned_str = cleaned_str.replace(',', '.')
        # Remove any non-numeric characters except the decimal point
        numeric_str = re.sub(r'[^\d.]', '', cleaned_str)
        if not numeric_str:
            return None
        return round(float(numeric_str), 2)
    except (ValueError, TypeError):
        return None

def parse_date(value_str):
    """Parses a DD/MM/YYYY string into a YYYY-MM-DD string."""
    if not value_str:
        return None
    try:
        cleaned_str = ocr_fix(value_str)
        # Flexible match for date format
        match = re.search(r'(\d{1,2})[/\s.-](\d{1,2})[/\s.-](\d{4})', cleaned_str)
        if match:
            day, month, year = map(int, match.groups())
            if 0 < day <= 31 and 0 < month <= 12 and year > 1900:
                return f"{year:04d}-{month:02d}-{day:02d}"
        return None
    except (ValueError, TypeError):
        return None

# --- Field-Specific Extraction Functions ---

def get_barcode(text):
    """Extracts the 47 or 48-digit barcode (linha digitável)."""
    # Fix common OCR errors before searching
    fixed_text = ocr_fix(text)
    
    # Pattern for formatted barcode blocks
    block_pattern = r'\b(\d{5}[.\s]?\d{5})\s*(\d{5}[.\s]?\d{6})\s*(\d{5}[.\s]?\d{6})\s*(\d)\s*(\d{14})\b'
    match = re.search(block_pattern, fixed_text)
    if match:
        return re.sub(r'[^\d]', '', match.group(0))

    # Fallback: find any line with 47-48 digits
    for line in fixed_text.split('\n'):
        numeric_line = re.sub(r'[^\d]', '', line)
        if 47 <= len(numeric_line) <= 48:
            return numeric_line
            
    # Fallback: find a contiguous block of 47-48 digits anywhere
    contiguous_match = re.search(r'\b\d{47,48}\b', fixed_text)
    if contiguous_match:
        return contiguous_match.group(0)
        
    return None

def get_pix_code(text):
    """Extracts the PIX 'Copia e Cola' code."""
    # The PIX code typically starts with '000201' and ends with a 4-char checksum after '6304'
    match = re.search(r'(000201[\s\S]*?6304[A-F0-9]{4})', text, re.IGNORECASE)
    if match:
        # Remove all whitespace, including newlines, from the matched code
        return re.sub(r'\s+', '', match.group(1))
    return None

def get_last_match(pattern, text):
    """Finds the last match for a given regex pattern in the text."""
    matches = re.findall(pattern, text, re.IGNORECASE)
    return clean_text(matches[-1]) if matches else None

def get_first_match_multiline(pattern, text):
    """Finds the first match for a pattern that might capture multi-line content."""
    match = re.search(pattern, text, re.IGNORECASE)
    return clean_text(match.group(1)) if match else None

def get_amounts(text):
    """Extracts various amount fields, prioritizing 'Valor Cobrado'."""
    val_doc_pattern = r'(?:\(=\))?\s*Valor do Documento\s*R\$\s*([\d,.]+)'
    val_cob_pattern = r'\(=\)\s*Valor Cobrado\s*R\$\s*([\d,.]+)'
    discount_pattern = r'\s*\((?:-)\)\s*(?:Desconto|Abatimento)\s*R\$\s*([\d,.]+)'
    interest_pattern = r'\s*\((?:\+)\)\s*(?:Juros|Multa|Mora|Acréscimos)\s*R\$\s*([\d,.]+)'
    
    document_amount = parse_currency(get_last_match(val_doc_pattern, text))
    cobrado_amount = parse_currency(get_last_match(val_cob_pattern, text))
    
    # Final amount is 'Valor Cobrado' if available and positive, otherwise 'Valor do Documento'
    final_amount = cobrado_amount if cobrado_amount is not None and cobrado_amount > 0 else document_amount
    
    return {
        "documentAmount": document_amount,
        "amount": final_amount,
        "discount": parse_currency(get_last_match(discount_pattern, text)),
        "interestAndFines": parse_currency(get_last_match(interest_pattern, text)),
    }
    
def get_guide_number(text):
    """Prioritizes 'Nosso Número' and falls back to 'Nº Documento'."""
    # Priority 1: Nosso Número (captures numbers, dots, hyphens, slashes)
    nosso_numero_pattern = r'Nosso\s*N[úu]mero\s*([\d./-]+)'
    match = re.search(nosso_numero_pattern, text, re.IGNORECASE)
    if match and match.group(1):
        # Return it cleaned of non-numeric characters for consistency
        return re.sub(r'[^\d]', '', match.group(1))

    # Priority 2: Nº Documento/Guia
    doc_numero_pattern = r'N[º°o\.]?\s*Documento(?:[/]?Guia)?\s*([^\n\r]+)'
    match = re.search(doc_numero_pattern, text, re.IGNORECASE)
    if match and match.group(1):
        # The number can be on the same line or the next, this captures it
        return clean_text(match.group(1).strip())
        
    return None

def get_detailed_costs(text):
    """Extracts detailed cost items like Emolumento, FERC, etc."""
    costs = {}
    # Ordered list of known labels
    labels = ['Emolumento', 'TSNR', 'FERC', 'FERM', 'FUNSEG', 'ISS', 'Tarifa Banco']
    text_slice = text
    
    # Find the "Totais" or "Descrição do Ato" section to limit the search area
    summary_match = re.search(r'(?i)(?:Descrição do Ato|Totais)', text)
    if summary_match:
        text_slice = text[summary_match.start():]
        
    for label in labels:
        # Pattern to find the label and the first currency value after it
        pattern = re.compile(rf'{re.escape(label)}\s*R\$\s*([\d,.]+)', re.IGNORECASE)
        match = pattern.search(text_slice)
        if match:
            value = parse_currency(match.group(1))
            if value is not None:
                costs[label] = value
    return costs if costs else None

# --- Main Extraction Function ---

def extract_boleto_info(pdf_path):
    """Opens a PDF and extracts all relevant boleto information."""
    text_content = ""
    try:
        with fitz.open(pdf_path) as doc:
            for page in doc:
                # 'sort=True' helps reconstruct reading order, crucial for tables/columns
                text_content += page.get_text("text", sort=True) + "\n"
    except Exception as e:
        return {"error": f"PyMuPDF failed to read the PDF file: {str(e)}"}

    # Define patterns for multiline fields
    recipient_pattern = r'Cedente\s*\n([\s\S]*?)(?=\nAgência / Código do Cedente|\nNosso Número)'
    drawee_pattern = r'Sacado\s*\n([\s\S]*?)(?=\nSacador / Avalista|\nInstruções)'
    due_date_pattern = r'Vencimento\s*(\d{2}/\d{2}/\d{4})'
    doc_date_pattern = r'Data do Documento\s*(\d{2}/\d{2}/\d{4})'

    amounts = get_amounts(text_content)

    result = {
        "recipient": get_first_match_multiline(recipient_pattern, text_content),
        "drawee": get_first_match_multiline(drawee_pattern, text_content),
        "documentDate": parse_date(get_last_match(doc_date_pattern, text_content)),
        "dueDate": parse_date(get_last_match(due_date_pattern, text_content)),
        "documentAmount": amounts["documentAmount"],
        "amount": amounts["amount"],
        "discount": amounts["discount"],
        "interestAndFines": amounts["interestAndFines"],
        "barcode": get_barcode(text_content),
        "guideNumber": get_guide_number(text_content),
        "pixQrCodeText": get_pix_code(text_content),
        "detailedCosts": get_detailed_costs(text_content),
    }

    return result

if __name__ == "__main__":
    if len(sys.argv) > 1:
        pdf_file_path = sys.argv[1]
        if not os.path.exists(pdf_file_path):
            error_msg = {"error": "PDF file not found at path: " + pdf_file_path}
            print(json.dumps(error_msg, ensure_ascii=False), file=sys.stderr)
            sys.exit(1)
            
        extraction_result = extract_boleto_info(pdf_file_path)
        print(json.dumps(extraction_result, ensure_ascii=False))
    else:
        error_msg = {"error": "No PDF file path provided."}
        print(json.dumps(error_msg, ensure_ascii=False), file=sys.stderr)
        sys.exit(1)
